#!/usr/bin/env ruby
# kexec-reboot - Easily choose a kernel to kexec
# Copyright (C) 2014 Michael Hampton <support@ringingliberty.com>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require 'optparse'

# Find a mount point given the device special
def device_to_mount_point(device)
  if File.ftype(device) != "blockSpecial" then
    STDERR.puts("Device #{device} isn't a block device\n")
    return nil
  end
  mount_point = nil
  mounts = open("/proc/mounts").each_line do |mount|
    line = mount.split
    if line[0] == device then
      mount_point = line[1]
      break
    end
  end
  mount_point = "" if mount_point == "/"  # Eliminate double /
  if mount_point.nil? then
    STDERR.puts "Can't find the mount point for device #{device}\n"
    return nil
  end
  mount_point
end

# Find a mount point given the GRUB device and device map
def device_map_to_mount_point(device, device_map)
  dev = device.match(/(hd\d+)/)
  part = device.match(/hd\d+,(\d+)/)
  mount_point = device_map.match(/\(#{dev[1]}\)\s+(.+)$/)
  mount_point_part = 1 + Integer(part[1]) if !part.nil?
  # Partitions requiring a p, e.g. /dev/cciss/c0d0p1
  device_path = "#{mount_point[1]}p#{mount_point_part}"
  if !File.exists?(device_path) then
    # Plain parittions e.g. /dev/sda1
    device_path = "#{mount_point[1]}#{mount_point_part}"
    if !File.exists?(device_path) then
      STDERR.puts("Can't find partition #{mount_point_part} for the device #{mount_point[1]} from #{device}\n")
      return nil
    end
  end
  device_to_mount_point("#{mount_point[1]}#{mount_point_part}")
end

# Find a mount point given the device UUID
def uuid_to_mount_point(uuid)
  begin
    device = File.realpath("/dev/disk/by-uuid/#{uuid}")
  rescue Errno::ENOENT
    STDERR.puts "No such file or directory, uuid #{uuid}\n"
    return nil
  end
  device_to_mount_point(device)
end

# Load the available kernels from the given GRUB 1 configuration file
def load_kernels_grub(config)
  device_map = open("/boot/grub/device.map").read
  entries = Array.new
  config.scan(/title (.+?$).+?root \(([^\)]+)\).+?kernel ([^ ]+) (.+?)$.+?initrd (.+?$)/m).each do |entry|
    mount_point = device_map_to_mount_point(entry[1], device_map)
    name = entry[0].strip
    kernel = "#{mount_point}#{entry[2]}"
    initrd = "#{mount_point}#{entry[4]}"
    cmdline = entry[3].strip
    # Sanity check the kernel and initrd; they must be present
    if !File.readable?(kernel) then
      STDERR.puts "Kernel #{kernel} is not readable\n"
      next
    end
    if !File.readable?(initrd) then
      STDERR.puts "Initrd #{initrd} is not readable\n"
      next
    end
    entries.push({
      "name"    => name,
      "kernel"  => kernel,
      "initrd"  => initrd,
      "cmdline" => cmdline,
    })
  end
  entries
end

# Load the available kernels from the given GRUB 2 configuration file
def load_kernels_grub2(config)
  entries = Array.new
  config.scan(/menuentry '([^']+)'.+?\{.+?search.+?([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}).+?linux(16)?\s+([^ ]+) (.+?)$.+?initrd(16)?\s+(.+?)$.+?\}/m).each do |entry|
    mount_point = uuid_to_mount_point(entry[1])
    name = entry[0].strip
    kernel = "#{mount_point}#{entry[3]}"
    initrd = "#{mount_point}#{entry[6]}"
    cmdline = entry[4].strip
    # Sanity check the kernel and initrd; they must be present
    if !File.readable?(kernel) then
      STDERR.puts "Kernel #{kernel} is not readable\n"
      next
    end
    if !File.readable?(initrd) then
      STDERR.puts "Initrd #{initrd} is not readable\n"
      next
    end
    entries.push({
      "name"    => name,
      "kernel"  => kernel,
      "initrd"  => initrd,
      "cmdline" => cmdline,
    })
  end
  entries
end

# Load a grub configuration file and process it
def process_grub_config
  # TODO: Duplicate code smells, refactor this
  # First, locate the grub configuration file
  # We try GRUB 1 files first
  ["/boot/grub/menu.lst"].each do |file|
    begin
      entries = load_kernels_grub(open(file).read)
      if !entries.empty? then
        if $verbose then
          puts "Read GRUB configuration from #{file}\n"
        end
        return entries
      end
    rescue Errno::EACCES
      STDERR.puts("#{$!}\nYou must be root to run this utility.\n")
      exit 1
    rescue Errno::ENOENT
      next
    end
  end
  # Then we try GRUB 2 files
  ["/boot/grub2/grub.cfg", "/boot/grub/grub.cfg"].each do |file|
    begin
      entries = load_kernels_grub2(open(file).read)
      if !entries.empty? then
        if $verbose then
          puts "Read GRUB configuration from #{file}\n"
        end
        return entries
      end
    rescue Errno::EACCES
      STDERR.puts("#{$!}\nYou must be root to run this utility.\n")
      exit 1
    rescue Errno::ENOENT
      next
    end
  end
  STDERR.puts("Couldn't find a grub configuration anywhere!\n")
  exit 1
end

def kexec(entry)
  print "Staging kernel #{entry['name']}\n" if $verbose
  print "Unloading previous kexec target, if any\n" if $verbose
  `/sbin/kexec -u`
  print "Running /sbin/kexec -l #{entry['kernel']} --append='#{entry['cmdline']}' --initrd=#{entry['initrd']}\n" if $verbose
  fork do
    exec "/sbin/kexec", "-l", "#{entry['kernel']}", "--append=#{entry['cmdline']}", "--initrd=#{entry['initrd']}"
  end
end

def interactive_select_kernel
  entries = process_grub_config

  selection = nil
  loop do
    puts "\nSelect a kernel to stage:\n\n"

    entries.each_with_index do |entry, index|
      selection_number = index + 1
      puts "#{selection_number}: #{entry['name']}\n"
    end

    print "\nYour selection: "
    selection = gets.chomp
    begin
      selection = Integer(selection)
    rescue ArgumentError
      return nil
    end
    break if selection.between?(0, entries.count)
  end

  return nil if selection == 0
  entries[selection - 1]
end

def select_latest_kernel
  entries = process_grub_config
  entries.first
end

options = {}

opts = OptionParser.new do |opts|
  opts.banner = "Usage: kexec-reboot [options]"

  opts.on("-i", "--interactive", "Choose the kernel to stage from a list") do |i|
    options[:interactive] = i
  end
  opts.on("-l", "--latest", "Stage the latest kernel") do |l|
    options[:latest] = l
  end
  opts.on("-r", "--reboot", "Reboot immediately after staging the kernel") do |r|
    options[:reboot] = r
  end
  opts.on("-v", "--[no-]verbose", "Extra verbosity.") do |v|
    $verbose = v
  end
end

opts.parse!

if (options[:interactive]) then
  entry = interactive_select_kernel
  if (entry.nil?) then
    STDERR.puts "Canceled.\n"
    exit 1
  end
elsif (options[:latest]) then
  entry = select_latest_kernel
else
  STDERR.puts opts.help
  exit 1
end

if !entry.nil? then
  print "Staging #{entry['name']}\n"
  entry = kexec(entry)

  if options[:reboot] then
    `shutdown -r now`
  end
end
